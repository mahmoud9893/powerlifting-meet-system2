Okay, excellent idea! Embedding the actual code directly into the documentation makes it incredibly powerful and self-contained.

I will compile all the updated, working code snippets that we've developed so far and integrate them into the comprehensive documentation.

Here's the expanded documentation, including the source code for each relevant file:

---

# Powerlifting Meet Management System Documentation

## Project Overview

This project is a real-time web and mobile application designed to manage a powerlifting meet. It consists of a Flask backend, a Vue.js web frontend for organizers and public display, and a Vue.js mobile application for judges to submit scores. The system leverages WebSockets (Socket.IO) for instant updates across all connected clients.

## Current Project Structure

```
PowerliftingApp/
├── backend/
│   ├── app.py                  # Flask backend application
│   ├── powerlifting_meet.db    # SQLite database file (created on first run)
│   ├── requirements.txt        # Python dependencies
│   └── ... (other Flask related files/folders)
├── frontend/
│   ├── powerlifting-frontend/  # Vue.js web application (Organizer & Public Display)
│   │   ├── src/
│   │   │   ├── main.js
│   │   │   ├── router/
│   │   │   │   └── index.js
│   │   │   ├── views/
│   │   │   │   ├── OrganizerView.vue
│   │   │   │   └── PublicDisplayView.vue
│   │   │   └── App.vue           # Main App component
│   │   ├── package.json        # Node.js dependencies
│   │   └── ... (other Vue CLI config files)
│   └── ...
└── mobile_app/
    └── judge-app/              # Vue.js mobile application (Judge App)
        ├── src/
        │   ├── main.js
        │   │   ├── router/
        │   │   │   └── index.js
        │   │   ├── views/
        │   │   │   └── JudgeView.vue
        │   │   └── App.vue       # Main App component
        │   └── ... (other Vue component files)
        ├── capacitor.config.json # Capacitor configuration
        ├── android/            # Android native project (generated by Capacitor)
        ├── ios/                # iOS native project (generated by Capacitor)
        ├── package.json        # Node.js dependencies
        └── ... (other Vue CLI / Capacitor config files)
```

## Core Components and Technologies

1.  **Backend:**
    * **Framework:** Flask
    * **Database:** SQLAlchemy (ORM) with SQLite (for development/local storage)
    * **Real-time Communication:** Flask-SocketIO
    * **Cross-Origin Handling:** Flask-CORS
    * **Functionality:** Manages lifter data, lift attempts, score submission, and broadcasts real-time updates.

2.  **Frontend (Web Application):**
    * **Framework:** Vue.js 3 (Composition API)
    * **Routing:** Vue Router
    * **Real-time Communication:** Socket.IO Client
    * **Purpose:** Provides an "Organizer Dashboard" for managing lifters and lifts, and a "Public Display" for real-time score viewing.

3.  **Mobile App (Judge Application):**
    * **Framework:** Vue.js 3 (Composition API)
    * **Routing:** Vue Router
    * **Real-time Communication:** Socket.IO Client
    * **Native Packaging:** Capacitor.js (for Android/iOS conversion)
    * **Purpose:** Allows individual judges to view the current active lift and submit their scores.

## Setup and Running Instructions

To run the entire system, you need to start the backend and both frontend applications (web and mobile app's web preview) in separate terminal windows.

### 1. Backend Setup (`PowerliftingApp/backend/`)

* **Prerequisites:** Python 3, `pip`
* **Installation:**
    1.  Navigate to the `backend` directory: `cd PowerliftingApp\backend`
    2.  Create a virtual environment (recommended): `python -m venv venv`
    3.  Activate the virtual environment:
        * Windows: `.\venv\Scripts\activate`
        * macOS/Linux: `source venv/bin/activate`
    4.  Install dependencies: `pip install -r requirements.txt`
* **Database Initialization:** The `powerlifting_meet.db` file will be created automatically on the first run of `app.py` if it doesn't exist, along with dummy data.
* **Running the Server:**
    ```bash
    python app.py
    ```
    * The server will run on `http://127.0.0.1:5000`. Keep this terminal running.

### 2. Frontend Web App Setup (`PowerliftingApp/frontend/powerlifting-frontend/`)

* **Prerequisites:** Node.js, npm (or Yarn)
* **Installation:**
    1.  Navigate to the web frontend directory: `cd PowerliftingApp\frontend\powerlifting-frontend`
    2.  Install dependencies: `npm install` (or `yarn install`)
* **Running the Development Server:**
    ```bash
    npm run serve
    ```
    * The app will run on `http://localhost:8080/`. Keep this terminal running.
    * **Access:**
        * Organizer Dashboard: `http://localhost:8080/organizer`
        * Public Display: `http://localhost:8080/display`

### 3. Mobile Judge App Setup (`PowerliftingApp/mobile_app/`)

* **Prerequisites:** Node.js, npm (or Yarn)
* **Installation:**
    1.  Navigate to the mobile app directory: `cd PowerliftingApp\mobile_app`
    2.  Install dependencies: `npm install` (or `yarn install`)
    3.  Install Capacitor dependencies if not already done: `npm install @capacitor/core @capacitor/cli`
    4.  Initialize Capacitor (if redoing setup): `npx cap init` (follow prompts for app name/ID, web directory is `dist`)
    5.  Add Capacitor platforms (requires Android Studio for Android, Xcode for iOS on macOS):
        * `npm install @capacitor/android`
        * `npx cap add android`
        * `npm install @capacitor/ios`
        * `npx cap add ios`
* **Running the Development Server (Web Preview):**
    ```bash
    npm run serve
    ```
    * The app will run on `http://localhost:8080/` (or another port). Keep this terminal running.
    * **Access:** `http://localhost:8080/`

* **Building and Running on Native Platforms (Requires Android Studio/Xcode):**
    1.  Build the Vue.js app for production: `npm run build`
    2.  Copy web assets to native project: `npx cap sync android` (or `ios`)
    3.  Open the native project: `npx cap open android` (or `ios`)
    4.  In Android Studio/Xcode, run the app on an emulator or physical device.

    **Important for Native Mobile Connectivity:** When running on a physical device or emulator, `http://localhost:5000` from the mobile app will try to connect to `localhost` *on the device itself*, not your development machine.
    * **Solution:** Before running `npm run build` and `npx cap sync`, you MUST change `http://localhost:5000` in `PowerliftingApp/mobile_app/src/main.js` and `PowerliftingApp/mobile_app/src/views/JudgeView.vue` to your **computer's actual local IP address** (e.g., `http://192.168.1.XX:5000`). You can find your IP address by running `ipconfig` (Windows) or `ifconfig` / `ip a` (macOS/Linux) in your terminal.
    * Remember to revert this back to `localhost` if you primarily test in the browser.

## Implemented Features

* **Lifter Management:**
    * Add new lifters via the Organizer Dashboard.
    * Display all registered lifters.
* **Lift Attempt Management:**
    * Set any pending lift as the "Current Lift" from the Organizer Dashboard.
    * Real-time display of the current active lift on the Public Display and Judge App.
* **Score Submission:**
    * Judges can view the active lift on their mobile app.
    * Judges can submit "Good Lift" or "No Lift" scores.
    * The system tracks scores from up to 3 judges.
    * Determines overall lift result (2 out of 3 good scores = GOOD LIFT).
* **Real-time Updates (Socket.IO):**
    * New lifters added are instantly visible on the Organizer Dashboard.
    * Changes to the active lift (set by Organizer) are instantly updated on Public Display and Judge App.
    * Judge scores are instantly reflected on the Public Display and Organizer Dashboard.
* **Database:**
    * SQLite database (`powerlifting_meet.db`) manages `Lifter` and `LiftAttempt` records.
    * Dummy data is populated on the first backend run for quick testing.

## Key Technical Details and Decisions

* **CORS:** `Flask-CORS` is enabled for all HTTP routes in the Flask backend (`CORS(app)`) to allow cross-origin requests from the Vue.js frontends. `Flask-SocketIO` also has `cors_allowed_origins="*"` for WebSocket connections.
* **Socket.IO Event Names:**
    * `lifter_added`: Emitted by backend when a new lifter is added (to update Organizer).
    * `active_lift_changed`: Emitted by backend when the Organizer sets a new active lift (to update Public Display, Judge App).
    * `lift_updated`: Emitted by backend when a score is submitted or a lift's status changes (to update all relevant clients).
* **Vue.js Composition API:** All frontend applications use Vue 3's Composition API (`setup()`, `ref`, `onMounted`, `onUnmounted`) for managing component state and logic.
* **Global Socket Instance:** The Socket.IO client instance is attached to `app.config.globalProperties.$socket` in `main.js` for both frontend apps, making it accessible as `this.$socket` (or `app.config.globalProperties.$socket` directly) in any component, though direct `io("url")` within `setup` is also used for clarity in some views.
* **Judge ID Handling:** The Judge app uses a simple input field for the judge to enter their ID (1, 2, or 3) before submitting scores. In a production scenario, this would typically be handled via a secure login system.

## Source Code

### `PowerliftingApp/backend/requirements.txt`

```
Flask==2.3.2
Flask-SQLAlchemy==3.0.3
Flask-SocketIO==5.3.0
Flask-CORS==3.0.10
eventlet==0.33.0
```

### `PowerliftingApp/backend/app.py`

```python
import os
from datetime import datetime
from flask import Flask, request, jsonify
from flask_sqlalchemy import SQLAlchemy
from flask_socketio import SocketIO, emit
from flask_cors import CORS

basedir = os.path.abspath(os.path.dirname(__file__))

app = Flask(__name__)
app.config['SQLALCHEMY_DATABASE_URI'] = 'sqlite:///' + os.path.join(basedir, 'powerlifting_meet.db')
app.config['SQLALCHEMY_TRACK_MODIFICATIONS'] = False

db = SQLAlchemy(app)
CORS(app) # Enable CORS for all HTTP routes
socketio = SocketIO(app, cors_allowed_origins="*") # Enable CORS for SocketIO

# --- Database Models ---
class Lifter(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    name = db.Column(db.String(100), nullable=False)
    weight_class = db.Column(db.String(20), nullable=False) # e.g., 83kg, 105kg
    lift_attempts = db.relationship('LiftAttempt', backref='lifter', lazy=True, cascade="all, delete-orphan")

    def __repr__(self):
        return f"<Lifter {self.name} ({self.weight_class})>"

class LiftAttempt(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    lifter_id = db.Column(db.Integer, db.ForeignKey('lifter.id'), nullable=False)
    weight_lifted = db.Column(db.Float, nullable=False)
    attempt_number = db.Column(db.Integer, nullable=False) # 1st, 2nd, 3rd attempt
    status = db.Column(db.String(20), default='pending') # pending, active, completed
    judge1_score = db.Column(db.Boolean, nullable=True) # True for good, False for bad, None for not scored
    judge2_score = db.Column(db.Boolean, nullable=True)
    judge3_score = db.Column(db.Boolean, nullable=True)
    overall_result = db.Column(db.Boolean, nullable=True) # True for good lift, False for no lift

    def __repr__(self):
        return f"<LiftAttempt {self.lifter_id} - {self.weight_lifted}kg - Attempt {self.attempt_number}>"

    def calculate_overall_result(self):
        scores = [self.judge1_score, self.judge2_score, self.judge3_score]
        # Filter out None values (unscored judges)
        actual_scores = [s for s in scores if s is not None]

        if len(actual_scores) < 3: # Need all 3 scores to determine overall result
            self.overall_result = None
            return False # Not enough scores yet

        good_lifts = sum(1 for s in actual_scores if s is True)
        no_lifts = sum(1 for s in actual_scores if s is False)

        if good_lifts >= 2:
            self.overall_result = True
        else:
            self.overall_result = False
        return True # Overall result has been determined

    def to_dict(self):
        lifter = Lifter.query.get(self.lifter_id)
        return {
            'id': self.id,
            'lifter_id': self.lifter_id,
            'lifter_name': lifter.name if lifter else 'Unknown',
            'weight_class': lifter.weight_class if lifter else 'Unknown',
            'weight_lifted': self.weight_lifted,
            'attempt_number': self.attempt_number,
            'status': self.status,
            'judge1_score': self.judge1_score,
            'judge2_score': self.judge2_score,
            'judge3_score': self.judge3_score,
            'overall_result': self.overall_result
        }

# --- Database Initialization (on first run) ---
with app.app_context():
    db.create_all()

    # Add dummy data if tables are empty
    if Lifter.query.count() == 0:
        print("Adding dummy data...")
        lifter1 = Lifter(name="John Doe", weight_class="83kg")
        lifter2 = Lifter(name="Jane Smith", weight_class="69kg")
        lifter3 = Lifter(name="Mike Johnson", weight_class="105kg")
        db.session.add_all([lifter1, lifter2, lifter3])
        db.session.commit()

        # Add dummy lift attempts for John Doe
        lift1_jd = LiftAttempt(lifter=lifter1, weight_lifted=200.0, attempt_number=1, status='pending')
        lift2_jd = LiftAttempt(lifter=lifter1, weight_lifted=210.0, attempt_number=2, status='pending')
        lift3_jd = LiftAttempt(lifter=lifter1, weight_lifted=220.0, attempt_number=3, status='pending')

        # Add dummy lift attempts for Jane Smith
        lift1_js = LiftAttempt(lifter=lifter2, weight_lifted=120.0, attempt_number=1, status='pending')
        lift2_js = LiftAttempt(lifter=lifter2, weight_lifted=125.0, attempt_number=2, status='pending')

        db.session.add_all([lift1_jd, lift2_jd, lift3_jd, lift1_js, lift2_js])
        db.session.commit()
        print("Dummy data added.")

# --- API Endpoints ---
@app.route('/lifters', methods=['GET'])
def get_lifters():
    lifters = Lifter.query.all()
    return jsonify([{'id': l.id, 'name': l.name, 'weight_class': l.weight_class} for l in lifters])

@app.route('/lifters', methods=['POST'])
def add_lifter():
    data = request.get_json()
    new_lifter = Lifter(name=data['name'], weight_class=data['weight_class'])
    db.session.add(new_lifter)
    db.session.commit()
    # Also create default 3 lift attempts for the new lifter
    for i in range(1, 4):
        # Assign a sensible starting weight, e.g., 100kg for demonstration
        # In a real app, this might come from coach input or a formula
        default_weight = 100.0 + (i - 1) * 10
        new_lift_attempt = LiftAttempt(
            lifter_id=new_lifter.id,
            weight_lifted=default_weight,
            attempt_number=i,
            status='pending'
        )
        db.session.add(new_lift_attempt)
    db.session.commit()
    socketio.emit('lifter_added', new_lifter.to_dict()) # Broadcast new lifter
    return jsonify({'id': new_lifter.id, 'name': new_lifter.name, 'weight_class': new_lifter.weight_class}), 201

@app.route('/lifts', methods=['GET'])
def get_lifts():
    lifts = LiftAttempt.query.all()
    return jsonify([lift.to_dict() for lift in lifts])

@app.route('/current_lift', methods=['GET'])
def get_current_lift():
    active_lift = LiftAttempt.query.filter_by(status='active').first()
    if active_lift:
        return jsonify(active_lift.to_dict())
    return jsonify({"message": "No active lift"}), 404

@app.route('/set_active_lift/<int:lift_id>', methods=['POST'])
def set_active_lift(lift_id):
    with app.app_context():
        # Deactivate any currently active lift
        current_active = LiftAttempt.query.filter_by(status='active').first()
        if current_active:
            current_active.status = 'completed' # Or 'pending' if it was never attempted
            # Reset scores for the completed lift for cleanliness if needed
            current_active.judge1_score = None
            current_active.judge2_score = None
            current_active.judge3_score = None
            current_active.overall_result = None
            db.session.add(current_active) # Mark as completed

        # Set the new lift as active
        new_active = LiftAttempt.query.get(lift_id)
        if new_active:
            new_active.status = 'active'
            # Reset scores for the new active lift
            new_active.judge1_score = None
            new_active.judge2_score = None
            new_active.judge3_score = None
            new_active.overall_result = None
            db.session.add(new_active)
            db.session.commit()
            socketio.emit('active_lift_changed', new_active.to_dict()) # Broadcast change
            socketio.emit('lift_updated', new_active.to_dict()) # Also send as lift_updated for detailed view
            return jsonify(new_active.to_dict())
        return jsonify({"message": "Lift not found"}), 404

@app.route('/submit_score', methods=['POST'])
def submit_score():
    data = request.get_json()
    lift_id = data.get('lift_id')
    judge_number = data.get('judge_number')
    score = data.get('score') # True for good, False for bad

    if not all([lift_id, judge_number, score is not None]):
        return jsonify({"error": "Missing data"}), 400

    lift = LiftAttempt.query.get(lift_id)
    if not lift:
        return jsonify({"error": "Lift not found"}), 404

    if lift.status != 'active':
        return jsonify({"error": "Only active lifts can be scored"}), 400

    try:
        if judge_number == 1:
            lift.judge1_score = score
        elif judge_number == 2:
            lift.judge2_score = score
        elif judge_number == 3:
            lift.judge3_score = score
        else:
            return jsonify({"error": "Invalid judge number"}), 400

        db.session.commit()

        # After committing individual score, try to calculate overall result
        if lift.calculate_overall_result():
            db.session.commit() # Commit again if overall result changed

        socketio.emit('lift_updated', lift.to_dict()) # Broadcast update
        return jsonify(lift.to_dict())

    except Exception as e:
        db.session.rollback()
        return jsonify({"error": str(e)}), 500

# --- Socket.IO Events (for completeness, though most logic is in API routes) ---
@socketio.on('connect')
def test_connect():
    print('Client connected')

@socketio.on('disconnect')
def test_disconnect():
    print('Client disconnected')

# You can add more socket handlers here if needed for direct client-to-server messaging
# that doesn't involve an HTTP request first.

if __name__ == '__main__':
    socketio.run(app, debug=True, allow_unsafe_werkzeug=True) # allow_unsafe_werkzeug for auto-reload with eventlet
```

### `PowerliftingApp/frontend/powerlifting-frontend/src/main.js`

```javascript
import { createApp } from 'vue'
import App from './App.vue'
import router from './router'
import store from './store'
import { io } from "socket.io-client"; // Import Socket.IO client

const app = createApp(App)

// Connect to your Flask backend
const socket = io("http://localhost:5000");

// Make socket available globally in Vue components
app.config.globalProperties.$socket = socket;

// Optional: Log connection status
socket.on('connect', () => {
  console.log('Frontend connected to backend Socket.IO');
});

socket.on('disconnect', () => {
  console.log('Frontend disconnected from backend Socket.IO');
});

app.use(store).use(router).mount('#app')
```

### `PowerliftingApp/frontend/powerlifting-frontend/src/router/index.js`

```javascript
import { createRouter, createWebHistory } from 'vue-router'
import OrganizerView from '../views/OrganizerView.vue'
import PublicDisplayView from '../views/PublicDisplayView.vue'

const routes = [
  {
    path: '/',
    redirect: '/organizer' // Default route to OrganizerView
  },
  {
    path: '/organizer',
    name: 'Organizer',
    component: OrganizerView
  },
  {
    path: '/display',
    name: 'PublicDisplay',
    component: PublicDisplayView
  }
]

const router = createRouter({
  history: createWebHistory(),
  routes
})

export default router
```

### `PowerliftingApp/frontend/powerlifting-frontend/src/views/OrganizerView.vue`

```vue
<template>
  <div class="organizer-container">
    <h1>Organizer Dashboard</h1>

    <section class="add-lifter-section">
      <h2>Add New Lifter</h2>
      <form @submit.prevent="addLifter">
        <input v-model="newLifter.name" placeholder="Lifter Name" required />
        <input
          v-model="newLifter.weight_class"
          placeholder="Weight Class (e.g., 83kg)"
          required
        />
        <button type="submit">Add Lifter</button>
      </form>
    </section>

    <section class="lifter-queue">
      <h2>Lifter Queue</h2>
      <div v-if="currentLift" class="current-lift">
        <h3>Current Lift:</h3>
        <p>
          {{ currentLift.lifter_name }} ({{ currentLift.weight_class }}) -
          {{ currentLift.weight_lifted }}kg - Attempt
          {{ currentLift.attempt_number }}
        </p>
        <div class="scores">
          Judge 1: <span :class="getScoreClass(currentLift.judge1_score)">{{ formatScore(currentLift.judge1_score) }}</span> |
          Judge 2: <span :class="getScoreClass(currentLift.judge2_score)">{{ formatScore(currentLift.judge2_score) }}</span> |
          Judge 3: <span :class="getScoreClass(currentLift.judge3_score)">{{ formatScore(currentLift.judge3_score) }}</span>
        </div>
        <p v-if="currentLift.overall_result !== null">
          Overall Result: <span :class="currentLift.overall_result ? 'score-good' : 'score-bad'">{{ currentLift.overall_result ? 'GOOD LIFT' : 'NO LIFT' }}</span>
        </p>
      </div>
      <div v-else class="current-lift">
        <h3>Current Lift:</h3>
        <p>No active lift currently.</p>
      </div>

      <div class="upcoming-lifts">
        <h3>Upcoming Lifts:</h3>
        <ul v-if="pendingLifts.length">
          <li v-for="lift in pendingLifts" :key="lift.id">
            {{ lift.lifter_name }} ({{ lift.weight_class }}) -
            {{ lift.weight_lifted }}kg - Attempt
            {{ lift.attempt_number }}
            <button @click="setActiveLift(lift.id)">Set Active</button>
          </li>
        </ul>
        <p v-else>No upcoming lifts.</p>
      </div>
    </section>

    <section class="all-lifters-section">
      <h2>All Lifters</h2>
      <ul>
        <li v-for="lifter in allLifters" :key="lifter.id">
          {{ lifter.name }} ({{ lifter.weight_class }})
        </li>
      </ul>
    </section>
  </div>
</template>

<script>
import { ref, onMounted, onUnmounted } from 'vue';
import { io } from "socket.io-client";

export default {
  name: "OrganizerView",
  setup() {
    // --- Reactive State ---
    const allLifters = ref([]);
    const currentLift = ref(null);
    const pendingLifts = ref([]);
    const newLifter = ref({ name: "", weight_class: "" });

    // Initialize socket once when the component setup runs
    const socket = io("http://localhost:5000"); // This is correctly declared and accessible

    // --- Functions (MUST be defined inside setup) ---
    const fetchLifters = async () => {
      try {
        const response = await fetch("http://localhost:5000/lifters");
        const data = await response.json();
        allLifters.value = data;
      } catch (error) {
        console.error("Error fetching lifters:", error);
      }
    };

    const fetchCurrentAndPendingLifts = async () => {
      try {
        const allLiftsResponse = await fetch("http://localhost:5000/lifts");
        if (allLiftsResponse.ok) {
          const allLifts = await allLiftsResponse.json();

          const activeLift = allLifts.find((lift) => lift.status === "active");
          currentLift.value = activeLift || null;

          pendingLifts.value = allLifts.filter(
            (lift) => lift.status === "pending" && (!activeLift || lift.id !== activeLift.id)
          );
        }
      } catch (error) {
        console.error("Error fetching lifts:", error);
      }
    };

    const addLifter = async () => {
      try {
        const response = await fetch("http://localhost:5000/lifters", {
          method: "POST",
          headers: {
            "Content-Type": "application/json",
          },
          body: JSON.stringify(newLifter.value),
        });
        if (response.ok) {
          const addedLifter = await response.json();
          console.log("Lifter added successfully:", addedLifter);
          newLifter.value = { name: "", weight_class: "" };
          fetchLifters(); // Refresh all lifters
        } else {
          const errorData = await response.json();
          console.error("Failed to add lifter:", response.status, errorData);
        }
      } catch (error) {
        console.error("Error adding lifter (network or unexpected):", error);
      }
    };

    const setActiveLift = async (liftId) => {
      try {
        const response = await fetch(`http://localhost:5000/set_active_lift/${liftId}`, {
          method: "POST",
        });
        if (response.ok) {
          const activatedLift = await response.json();
          console.log("Lift activated:", activatedLift);
          fetchCurrentAndPendingLifts();
        } else {
          console.error("Failed to set active lift:", response.statusText);
        }
      } catch (error) {
        console.error("Error setting active lift:", error);
      }
    };

    const formatScore = (score) => {
      if (score === true) return "GOOD";
      if (score === false) return "BAD";
      return "Pending";
    };

    const getScoreClass = (score) => {
        if (score === true) return "score-good";
        if (score === false) return "score-bad";
        return "score-pending";
    };

    // --- Lifecycle Hooks ---
    onMounted(() => {
      fetchLifters();
      fetchCurrentAndPendingLifts(); // Initial fetch

      // Listen for Socket.IO events directly on the 'socket' variable
      socket.on("lifter_added", (lifter) => {
        console.log("Lifter added via WS:", lifter);
        fetchLifters(); // Re-fetch all lifters to update the list
      });

      socket.on("active_lift_changed", (lift) => {
        console.log("Active lift changed via WS:", lift);
        fetchCurrentAndPendingLifts(); // Re-fetch to update current and pending lists
      });

      socket.on("lift_updated", (lift) => {
        console.log("Lift updated via WS:", lift);
        if (currentLift.value && currentLift.value.id === lift.id) {
          currentLift.value = lift; // Update current lift details
        }
        fetchCurrentAndPendingLifts(); // Ensure queue and active lift are always fresh
      });
    });

    onUnmounted(() => {
      if (socket) {
        socket.off("lifter_added");
        socket.off("active_lift_changed");
        socket.off("lift_updated");
        socket.disconnect(); // Disconnect the socket when component is unmounted
      }
    });

    // --- Expose to Template ---
    return {
      allLifters,
      currentLift,
      pendingLifts,
      newLifter,
      addLifter,
      setActiveLift,
      formatScore, // Make sure formatScore is returned
      getScoreClass // Make sure getScoreClass is returned for template use
    };
  },
};
</script>

<style scoped>
.organizer-container {
  max-width: 900px;
  margin: 20px auto;
  padding: 20px;
  background-color: #f9f9f9;
  border-radius: 8px;
  box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
  font-family: Arial, sans-serif;
}

h1, h2, h3 {
  color: #333;
  text-align: center;
  margin-bottom: 20px;
}

section {
  background-color: #fff;
  border: 1px solid #ddd;
  border-radius: 5px;
  padding: 15px;
  margin-bottom: 20px;
}

/* Add Lifter Section */
.add-lifter-section form {
  display: flex;
  flex-direction: column;
  gap: 10px;
}

.add-lifter-section input {
  padding: 10px;
  border: 1px solid #ccc;
  border-radius: 4px;
}

.add-lifter-section button {
  padding: 10px 15px;
  background-color: #4CAF50;
  color: white;
  border: none;
  border-radius: 4px;
  cursor: pointer;
  font-size: 16px;
}

.add-lifter-section button:hover {
  background-color: #45a049;
}

/* Lifter Queue */
.current-lift {
  border-bottom: 1px solid #eee;
  padding-bottom: 15px;
  margin-bottom: 15px;
}

.current-lift p {
  font-size: 1.1em;
  font-weight: bold;
}

.scores {
  display: flex;
  justify-content: center;
  gap: 15px;
  margin-top: 10px;
}

.scores span {
  padding: 5px 10px;
  border-radius: 4px;
  font-weight: bold;
  color: white;
}

.score-good { background-color: green; }
.score-bad { background-color: red; }
.score-pending { background-color: orange; }


.upcoming-lifts ul {
  list-style: none;
  padding: 0;
}

.upcoming-lifts li {
  background-color: #eef;
  border: 1px solid #dde;
  padding: 10px;
  margin-bottom: 8px;
  border-radius: 4px;
  display: flex;
  justify-content: space-between;
  align-items: center;
}

.upcoming-lifts button {
  padding: 8px 12px;
  background-color: #007bff;
  color: white;
  border: none;
  border-radius: 4px;
  cursor: pointer;
}

.upcoming-lifts button:hover {
  background-color: #0056b3;
}

/* All Lifters Section */
.all-lifters-section ul {
  list-style: decimal; /* Ordered list */
  padding-left: 20px;
}

.all-lifters-section li {
  padding: 8px 0;
  border-bottom: 1px dashed #eee;
}

.all-lifters-section li:last-child {
  border-bottom: none;
}
</style>
```

### `PowerliftingApp/frontend/powerlifting-frontend/src/views/PublicDisplayView.vue`

```vue
<template>
  <div class="public-display-container">
    <h1>Live Lift Board</h1>

    <div v-if="currentLift" class="current-lift-info">
      <h2>CURRENT LIFT</h2>
      <p class="lifter-name">{{ currentLift.lifter_name }}</p>
      <p class="weight-class">({{ currentLift.weight_class }})</p>
      <p class="lift-details">{{ currentLift.weight_lifted }} kg - Attempt {{ currentLift.attempt_number }}</p>

      <div class="judge-scores">
        <div class="judge-score-item">
          <span>Judge 1:</span>
          <span :class="getScoreClass(currentLift.judge1_score)">{{ formatScore(currentLift.judge1_score) }}</span>
        </div>
        <div class="judge-score-item">
          <span>Judge 2:</span>
          <span :class="getScoreClass(currentLift.judge2_score)">{{ formatScore(currentLift.judge2_score) }}</span>
        </div>
        <div class="judge-score-item">
          <span>Judge 3:</span>
          <span :class="getScoreClass(currentLift.judge3_score)">{{ formatScore(currentLift.judge3_score) }}</span>
        </div>
      </div>

      <div v-if="currentLift.overall_result !== null" class="overall-result">
        <h2>OVERALL RESULT</h2>
        <p :class="currentLift.overall_result ? 'result-good' : 'result-bad'">
          {{ currentLift.overall_result ? 'GOOD LIFT' : 'NO LIFT' }}
        </p>
      </div>
      <div v-else class="overall-result">
        <h2>OVERALL RESULT</h2>
        <p class="result-pending">PENDING</p>
      </div>

    </div>
    <div v-else class="no-current-lift">
      <h2>No Active Lift Currently</h2>
      <p>Please wait for the organizer to set the next lift.</p>
    </div>
  </div>
</template>

<script>
import { ref, onMounted, onUnmounted } from 'vue';
import { io } from 'socket.io-client';

export default {
  name: 'PublicDisplayView',
  setup() {
    const currentLift = ref(null);
    let socket = null; // Declare socket here for onUnmounted access

    const fetchCurrentLift = async () => {
      try {
        const response = await fetch('http://localhost:5000/current_lift');
        if (response.ok) {
          const data = await response.json();
          currentLift.value = data;
        } else if (response.status === 404) {
          currentLift.value = null; // No active lift found
        }
      } catch (error) {
        console.error('Error fetching current lift:', error);
      }
    };

    const formatScore = (score) => {
      if (score === true) return 'GOOD';
      if (score === false) return 'BAD';
      return 'PENDING';
    };

    const getScoreClass = (score) => {
      if (score === true) return 'score-good';
      if (score === false) return 'score-bad';
      return 'score-pending';
    };

    onMounted(() => {
      fetchCurrentLift(); // Initial fetch

      // Connect to Socket.IO
      socket = io('http://localhost:5000');

      // Listen for active lift changes
      socket.on('active_lift_changed', (lift) => {
        console.log('Active lift changed via WS:', lift);
        currentLift.value = lift;
      });

      // Listen for lift updates (e.g., judge scores coming in)
      socket.on('lift_updated', (lift) => {
        console.log('Lift updated via WS:', lift);
        if (currentLift.value && currentLift.value.id === lift.id) {
          currentLift.value = lift; // Update current lift details if it's the same lift
        }
      });
    });

    onUnmounted(() => {
      // Clean up socket listeners when component is unmounted
      if (socket) {
        socket.off('active_lift_changed');
        socket.off('lift_updated');
        socket.disconnect();
      }
    });

    return {
      currentLift,
      formatScore,
      getScoreClass
    };
  }
};
</script>

<style scoped>
.public-display-container {
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  min-height: 100vh;
  background-color: #2c3e50; /* Dark blue/grey */
  color: #ecf0f1; /* Light text */
  font-family: 'Arial', sans-serif;
  padding: 20px;
  box-sizing: border-box;
}

h1 {
  font-size: 3.5em;
  color: #f39c12; /* Orange/Gold */
  margin-bottom: 40px;
  text-transform: uppercase;
  letter-spacing: 2px;
  text-shadow: 3px 3px 6px rgba(0, 0, 0, 0.4);
}

.current-lift-info {
  background-color: #34495e; /* Slightly lighter dark blue */
  border-radius: 15px;
  padding: 40px;
  box-shadow: 0 10px 20px rgba(0, 0, 0, 0.5);
  width: 100%;
  max-width: 700px;
  text-align: center;
  margin-bottom: 30px;
}

.current-lift-info h2 {
  font-size: 2.5em;
  color: #e74c3c; /* Red */
  margin-bottom: 20px;
  text-transform: uppercase;
}

.lifter-name {
  font-size: 4em;
  font-weight: bold;
  color: #ecf0f1;
  margin-bottom: 10px;
  text-transform: uppercase;
}

.weight-class {
  font-size: 1.8em;
  color: #bdc3c7;
  margin-bottom: 15px;
}

.lift-details {
  font-size: 2.5em;
  font-weight: bold;
  color: #2ecc71; /* Green */
  margin-bottom: 40px;
  text-shadow: 1px 1px 3px rgba(0, 0, 0, 0.2);
}

.judge-scores {
  display: flex;
  justify-content: space-around;
  margin-bottom: 40px;
  flex-wrap: wrap; /* Allow wrapping on smaller screens */
  gap: 20px;
}

.judge-score-item {
  display: flex;
  flex-direction: column;
  align-items: center;
  font-size: 1.5em;
  font-weight: bold;
  color: #bdc3c7;
}

.judge-score-item span:first-child {
  margin-bottom: 5px;
}

.judge-score-item span:last-child {
  padding: 10px 20px;
  border-radius: 10px;
  color: white;
  min-width: 120px; /* Ensure consistent button size */
  box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
}

.score-good { background-color: #28a745; /* Bootstrap success green */ }
.score-bad { background-color: #dc3545; /* Bootstrap danger red */ }
.score-pending { background-color: #ffc107; color: #333; /* Bootstrap warning yellow */ }

.overall-result {
  margin-top: 30px;
}

.overall-result h2 {
  font-size: 2.2em;
  color: #f39c12;
  margin-bottom: 15px;
  text-transform: uppercase;
}

.overall-result p {
  font-size: 5em;
  font-weight: bold;
  text-transform: uppercase;
  text-shadow: 4px 4px 8px rgba(0, 0, 0, 0.5);
}

.result-good { color: #1abc9c; /* Turquoise */ }
.result-bad { color: #e74c3c; /* Alizarin red */ }
.result-pending { color: #bdc3c7; } /* Silver */

.no-current-lift {
  background-color: #34495e;
  border-radius: 15px;
  padding: 50px;
  box-shadow: 0 10px 20px rgba(0, 0, 0, 0.5);
  width: 100%;
  max-width: 700px;
  text-align: center;
  margin-bottom: 30px;
}

.no-current-lift h2 {
  font-size: 2.5em;
  color: #bdc3c7;
  margin-bottom: 20px;
}

.no-current-lift p {
  font-size: 1.5em;
  color: #95a5a6;
}
</style>
```

### `PowerliftingApp/frontend/powerlifting-frontend/src/App.vue`

```vue
<template>
  <nav>
    <router-link to="/organizer">Organizer</router-link> |
    <router-link to="/display">Public Display</router-link>
  </nav>
  <router-view/>
</template>

<style>
#app {
  font-family: Avenir, Helvetica, Arial, sans-serif;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
  text-align: center;
  color: #2c3e50;
}

nav {
  padding: 30px;
}

nav a {
  font-weight: bold;
  color: #2c3e50;
}

nav a.router-link-exact-active {
  color: #42b983;
}
</style>
```

### `PowerliftingApp/mobile_app/src/main.js`

```javascript
import { createApp } from 'vue'
import App from './App.vue'
import router from './router'
import store from './store'
import { io } from "socket.io-client" // Import Socket.IO client

const app = createApp(App)

// Connect to your Flask backend.
// For browser testing, 'localhost:5000' is fine.
// FOR PHYSICAL MOBILE DEVICES/EMULATORS, YOU WILL NEED TO CHANGE 'localhost'
// TO YOUR COMPUTER'S ACTUAL LOCAL IP ADDRESS (e.g., 'http://192.168.1.XX:5000').
// We'll discuss this again in the testing section.
const socket = io("http://localhost:5000");

// Make socket instance globally available in Vue components
app.config.globalProperties.$socket = socket;

// Optional: Log connection status
socket.on('connect', () => {
  console.log('Mobile app connected to backend Socket.IO');
});

socket.on('disconnect', () => {
  console.log('Mobile app disconnected from backend Socket.IO');
});

app.use(store).use(router).mount('#app')
```

### `PowerliftingApp/mobile_app/src/router/index.js`

```javascript
import { createRouter, createWebHistory } from 'vue-router'
import JudgeView from '../views/JudgeView.vue' // Import your JudgeView

const routes = [
  {
    path: '/',
    name: 'judge', // Name this route 'judge'
    component: JudgeView
  }
]

const router = createRouter({
  history: createWebHistory(), // Using web history for initial web testing
  routes
})

export default router
```

### `PowerliftingApp/mobile_app/src/views/JudgeView.vue`

```vue
<template>
  <div class="judge-app-container">
    <h1>Judge Scorecard</h1>

    <div v-if="currentLift" class="current-lift-card">
      <h2>Current Lifter:</h2>
      <p class="lifter-name">{{ currentLift.lifter_name }}</p>
      <p class="details">
        Weight Class: {{ currentLift.weight_class }} | Attempt:
        {{ currentLift.attempt_number }}
      </p>
      <p class="weight-lifted">{{ currentLift.weight_lifted }} kg</p>

      <div class="judge-buttons">
        <button @click="submitScore(true)" class="good-lift-btn">
          <i class="fas fa-check-circle"></i> Good Lift
        </button>
        <button @click="submitScore(false)" class="bad-lift-btn">
          <i class="fas fa-times-circle"></i> No Lift
        </button>
      </div>

      <div class="current-scores">
        <h3>Current Scores:</h3>
        <p>Judge 1: <span :class="getScoreClass(currentLift.judge1_score)">{{ formatScore(currentLift.judge1_score) }}</span></p>
        <p>Judge 2: <span :class="getScoreClass(currentLift.judge2_score)">{{ formatScore(currentLift.judge2_score) }}</span></p>
        <p>Judge 3: <span :class="getScoreClass(currentLift.judge3_score)">{{ formatScore(currentLift.judge3_score) }}</span></p>
        <p v-if="currentLift.overall_result !== null" class="overall-result">
          Overall: <span :class="currentLift.overall_result ? 'score-good' : 'score-bad'">{{ currentLift.overall_result ? 'GOOD' : 'NO LIFT' }}</span>
        </p>
      </div>
    </div>
    <div v-else class="no-active-lift">
      <p>No active lift currently. Waiting for organizer...</p>
    </div>

    <div class="judge-id-section">
      <label for="judgeId">Your Judge ID (1-3):</label>
      <input
        type="number"
        id="judgeId"
        v-model.number="judgeId"
        min="1"
        max="3"
        placeholder="e.g., 1"
      />
      <p v-if="!judgeId" class="warning-text">Please enter your Judge ID to submit scores.</p>
    </div>
  </div>
</template>

<script>
import { ref, onMounted, onUnmounted } from "vue";
import { io } from "socket.io-client";

export default {
  name: "JudgeView",
  setup() {
    const currentLift = ref(null);
    const judgeId = ref(null); // Reactive variable for judge's ID
    let socket = null; // Declare socket here for onUnmounted access

    // Function to fetch the current active lift
    const fetchCurrentLift = async () => {
      try {
        const response = await fetch("http://localhost:5000/current_lift");
        if (response.ok) {
          const data = await response.json();
          currentLift.value = data;
        } else if (response.status === 404) {
          currentLift.value = null;
        }
      } catch (error) {
        console.error("Error fetching current lift:", error);
      }
    };

    // Function to submit a judge's score
    const submitScore = async (score) => {
      if (!judgeId.value || judgeId.value < 1 || judgeId.value > 3) {
        alert("Please enter a valid Judge ID (1, 2, or 3) before submitting a score.");
        return;
      }
      if (!currentLift.value) {
        alert("No active lift to score.");
        return;
      }

      try {
        const payload = {
          lift_id: currentLift.value.id,
          judge_number: judgeId.value,
          score: score, // true for good, false for bad
        };

        const response = await fetch("http://localhost:5000/submit_score", {
          method: "POST",
          headers: {
            "Content-Type": "application/json",
          },
          body: JSON.stringify(payload),
        });

        if (response.ok) {
          const updatedLift = await response.json();
          console.log("Score submitted successfully:", updatedLift);
          // The lift_updated WebSocket event will update currentLift.value
        } else {
          const errorData = await response.json();
          console.error("Failed to submit score:", response.status, errorData);
          alert(`Failed to submit score: ${errorData.error || response.statusText}`);
        }
      } catch (error) {
        console.error("Error submitting score:", error);
        alert("Network error or unexpected error while submitting score.");
      }
    };

    const formatScore = (score) => {
      if (score === true) return "GOOD";
      if (score === false) return "NO LIFT"; // Changed to NO LIFT for judge clarity
      return "PENDING";
    };

    const getScoreClass = (score) => {
      if (score === true) return "score-good";
      if (score === false) return "score-bad";
      return "score-pending";
    };

    onMounted(() => {
      fetchCurrentLift();

      // Connect to Socket.IO
      socket = io("http://localhost:5000");

      // Listen for lift updates (e.g., when judges submit scores or organizer sets new lift)
      socket.on("lift_updated", (lift) => {
        console.log("Lift updated via WS for judge:", lift);
        if (currentLift.value && currentLift.value.id === lift.id) {
          currentLift.value = lift; // Update current lift details
        } else if (lift.status === 'active') { // If a new lift becomes active, display it
            currentLift.value = lift;
        }
      });

      // Listen for active lift changes (when organizer sets a new lifter)
      socket.on("active_lift_changed", (lift) => {
        console.log("Active lift changed via WS for judge:", lift);
        currentLift.value = lift; // Immediately show the newly active lift
      });
    });

    onUnmounted(() => {
      if (socket) {
        socket.off("lift_updated");
        socket.off("active_lift_changed");
        socket.disconnect();
      }
    });

    return {
      currentLift,
      judgeId,
      submitScore,
      formatScore,
      getScoreClass,
    };
  },
};
</script>

<style scoped>
/* Font Awesome for icons */
@import url("https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/all.min.css");

.judge-app-container {
  display: flex;
  flex-direction: column;
  align-items: center;
  padding: 20px;
  min-height: 100vh;
  background-color: #2c3e50; /* Dark background */
  color: #ecf0f1; /* Light text */
  font-family: "Inter", sans-serif; /* Use Inter font */
  text-align: center;
}

h1 {
  font-size: 2.5em;
  color: #f39c12; /* Gold/Orange highlight */
  margin-bottom: 30px;
  text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.3);
}

.current-lift-card {
  background-color: #34495e; /* Slightly lighter dark background */
  border-radius: 15px;
  padding: 30px;
  box-shadow: 0 8px 16px rgba(0, 0, 0, 0.4);
  width: 100%;
  max-width: 500px;
  margin-bottom: 30px;
  box-sizing: border-box; /* Include padding in width */
}

.current-lift-card h2 {
  font-size: 1.8em;
  color: #e74c3c; /* Red for emphasis */
  margin-bottom: 15px;
}

.lifter-name {
  font-size: 2.8em;
  font-weight: bold;
  color: #ecf0f1;
  margin-bottom: 10px;
  text-transform: uppercase;
}

.details {
  font-size: 1.2em;
  color: #bdc3c7;
  margin-bottom: 15px;
}

.weight-lifted {
  font-size: 3.5em;
  font-weight: bold;
  color: #27ae60; /* Green for weight */
  margin-bottom: 30px;
  text-shadow: 1px 1px 3px rgba(0, 0, 0, 0.2);
}

.judge-buttons {
  display: flex;
  justify-content: space-around;
  gap: 20px;
  margin-bottom: 30px;
}

.judge-buttons button {
  flex: 1;
  padding: 15px 20px;
  border: none;
  border-radius: 10px;
  font-size: 1.3em;
  font-weight: bold;
  cursor: pointer;
  color: white;
  transition: all 0.2s ease-in-out;
  box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
  display: flex;
  align-items: center;
  justify-content: center;
  gap: 10px;
}

.good-lift-btn {
  background: linear-gradient(145deg, #2ecc71, #27ae60); /* Green gradient */
}

.good-lift-btn:hover {
  background: linear-gradient(145deg, #27ae60, #2ecc71);
  transform: translateY(-2px);
}

.bad-lift-btn {
  background: linear-gradient(145deg, #e74c3c, #c0392b); /* Red gradient */
}

.bad-lift-btn:hover {
  background: linear-gradient(145deg, #c0392b, #e74c3c);
  transform: translateY(-2px);
}

.judge-buttons button i {
  font-size: 1.5em;
}

.current-scores {
  background-color: #2c3e50;
  border-radius: 10px;
  padding: 15px;
  margin-top: 20px;
}

.current-scores h3 {
  font-size: 1.2em;
  color: #f39c12;
  margin-bottom: 10px;
}

.current-scores p {
  font-size: 1em;
  margin-bottom: 5px;
}

.current-scores span {
  padding: 3px 8px;
  border-radius: 5px;
  font-weight: bold;
  color: white;
}

.score-good {
  background-color: #2ecc71;
}
.score-bad {
  background-color: #e74c3c;
}
.score-pending {
  background-color: #f1c40f;
  color: #333;
}

.overall-result {
  font-size: 1.5em;
  font-weight: bold;
  margin-top: 15px;
}

.overall-result .score-good {
  background-color: #1abc9c;
}
.overall-result .score-bad {
  background-color: #e74c3c;
}

.no-active-lift {
  background-color: #34495e;
  border-radius: 15px;
  padding: 40px;
  box-shadow: 0 8px 16px rgba(0, 0, 0, 0.4);
  width: 100%;
  max-width: 500px;
  box-sizing: border-box;
}

.no-active-lift p {
  font-size: 1.5em;
  color: #bdc3c7;
}

.judge-id-section {
  background-color: #34495e;
  border-radius: 15px;
  padding: 20px;
  margin-top: 30px;
  width: 100%;
  max-width: 500px;
  box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
  box-sizing: border-box;
}

.judge-id-section label {
  font-size: 1.2em;
  margin-bottom: 10px;
  display: block;
  color: #f39c12;
}

.judge-id-section input {
  width: 80px;
  padding: 10px;
  font-size: 1.2em;
  border-radius: 8px;
  border: 1px solid #ccc;
  text-align: center;
  background-color: #ecf0f1;
  color: #333;
}

.warning-text {
  color: #e74c3c;
  font-weight: bold;
  margin-top: 10px;
}

/* Responsive adjustments */
@media (max-width: 600px) {
  h1 {
    font-size: 2em;
  }
  .lifter-name {
    font-size: 2em;
  }
  .weight-lifted {
    font-size: 3em;
  }
  .judge-buttons {
    flex-direction: column;
    gap: 15px;
  }
  .judge-buttons button {
    font-size: 1.1em;
    padding: 12px 15px;
  }
}
</style>
```

### `PowerliftingApp/mobile_app/src/App.vue`

```vue
<template>
  <router-view/>
</template>

<style>
/* Global styles for the app */
#app {
  font-family: "Inter", sans-serif;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
  text-align: center;
  color: #2c3e50; /* Default text color, overridden by component styles */
}

/* Remove default nav if it exists */
nav {
  display: none;
}
</style>
```

---

